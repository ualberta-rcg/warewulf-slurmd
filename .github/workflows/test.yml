name: Build and Commit Slurm DEB Packages

on:
  workflow_dispatch:
    inputs:
      slurm_version_override:
        description: 'Optional: Specific Slurm version to build (e.g., 23.11.7-1). Leave empty to use latest.'
        required: false
        default: ''
  schedule:
    - cron: '0 3 1 * *'  # Every month on the 1st at 03:00 UTC

jobs:
  build-debs:
    runs-on: ubuntu-24.04

    outputs:
      version: ${{ steps.vars.outputs.version }}
      skip_build: ${{ steps.version-check.outputs.skip_build }}

    steps:
      - name: üì¶ Checkout Repository
        uses: actions/checkout@v4
        with:
          # Fetch all history for all branches and tags
          fetch-depth: 0

      - name: üéØ Determine Target Slurm Version
        id: vars
        run: |
          set -e # Exit on error
          
          # Use the manual dispatch input first, then the repo variable as a fallback
          VERSION_OVERRIDE="${{ github.event.inputs.slurm_version_override || vars.SLURM_VERSION_OVERRIDE }}"

          if [ -n "$VERSION_OVERRIDE" ]; then
            echo "‚úÖ Using specified version override: $VERSION_OVERRIDE"
            VERSION="$VERSION_OVERRIDE"
          else
            echo "üîç No version override set. Detecting latest stable version..."
            
            # Fetch all tags from the SchedMD/slurm repo
            TAGS=$(curl -s -H "Accept: application/vnd.github.v3+json" https://api.github.com/repos/SchedMD/slurm/tags | jq -r '.[].name')
            
            # Filter for stable release tags (e.g., slurm-23-11-7-1) and get the latest
            LATEST_TAG=$(echo "$TAGS" \
              | grep -E '^slurm-[0-9]+-[0-9]+-[0-9]+-[0-9]+$' \
              | sort -V \
              | tail -n1)

            if [ -z "$LATEST_TAG" ]; then
              echo "‚ùå Could not determine the latest Slurm tag."
              exit 1
            fi

            VERSION="${LATEST_TAG#slurm-}"
            echo "üî¨ Detected latest version: $VERSION"
          fi
          
          # Construct the tag name and download URL
          TAG_NAME="slurm-${VERSION}"
          TARBALL_URL="https://codeload.github.com/SchedMD/slurm/tar.gz/refs/tags/${TAG_NAME}"

          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "tarball_url=${TARBALL_URL}" >> $GITHUB_OUTPUT
          
      - name: üõë Check if DEBs for this version already exist
        id: version-check
        run: |
          set -e
          OS_CODENAME="u2404" 
          
          # The version from the previous step
          VERSION="${{ steps.vars.outputs.version }}"
          
          # Convert Slurm version (e.g., 23-11-7-1) to Debian version (e.g., 23.11.7-1)
          DEB_VERSION=$(echo "$VERSION" | sed 's/-/./g; s/\./-/3')
          DEB_DIR="$GITHUB_WORKSPACE/slurm-debs"

          echo "üîç Checking for existing DEBs for version ${VERSION} (Debian version ${DEB_VERSION})"
          
          # Use `find` and `wc -l` to count matching files
          # The find command will return non-zero if no files are found, so we use `|| true`
          COUNT=$(find "$DEB_DIR" -type f -name "*_${DEB_VERSION}_*_${OS_CODENAME}.deb" 2>/dev/null | wc -l)

          if [ "$COUNT" -gt 0 ]; then
            echo "‚úÖ DEBs for Slurm ${VERSION} on ${OS_CODENAME} already exist. Skipping build."
            echo "skip_build=true" >> $GITHUB_OUTPUT
          else
            echo "üöß No existing DEBs found. Proceeding with build."
            echo "skip_build=false" >> $GITHUB_OUTPUT
          fi

      - name: üõ† Install Build Dependencies
        if: steps.version-check.outputs.skip_build == 'false'
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            devscripts equivs build-essential fakeroot debhelper curl jq git \
            libpmix-dev libpmix2 libopenmpi-dev libopenmpi3 openmpi-bin

      - name: üì• Download and Extract Slurm Source
        if: steps.version-check.outputs.skip_build == 'false'
        run: |
          set -e
          mkdir -p /tmp/slurm && cd /tmp/slurm
          echo "Downloading from ${{ steps.vars.outputs.tarball_url }}"
          curl -L "${{ steps.vars.outputs.tarball_url }}" -o slurm.tar.gz
          tar -xzf slurm.tar.gz
          # The extracted directory name should match the tag name
          mv slurm-${{ steps.vars.outputs.version }} slurm-src

      - name: üì¶ Build Slurm DEBs
        if: steps.version-check.outputs.skip_build == 'false'
        run: |
          set -e
          cd /tmp/slurm/slurm-src
          # Use mk-build-deps to install dependencies from debian/control
          sudo mk-build-deps -ir --tool='apt-get -qq -y --no-install-recommends' debian/control
          # Build binary packages only, without signing
          debuild -b -uc -us

      - name: üìÅ Rename and Move DEBs to Repo
        if: steps.version-check.outputs.skip_build == 'false'
        run: |
          set -e
          OS_CODENAME="u2404" # Change to ${{ matrix.os_codename }} if using a matrix
          DEST_DIR="$GITHUB_WORKSPACE/slurm-debs"
          mkdir -p "$DEST_DIR"
          
          # Move all .deb files from the parent directory
          for deb in /tmp/slurm/*.deb; do
            base=$(basename "$deb" .deb)
            mv "$deb" "$DEST_DIR/${base}_${OS_CODENAME}.deb"
          done
          echo "Moved DEBs to $DEST_DIR"
          ls -l "$DEST_DIR"

      - name: üì§ Commit and Push DEBs
        if: steps.version-check.outputs.skip_build == 'false'
        run: |
          set -e
          OS_CODENAME="u2404" # Change to ${{ matrix.os_codename }} if using a matrix
          
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          
          git add slurm-debs/
          # Check if there are staged changes before committing
          if git diff --staged --quiet; then
            echo "No changes to commit."
          else
            git commit -m "Add Slurm DEBs (v${{ steps.vars.outputs.version }}) for Ubuntu ${OS_CODENAME}"
            git push
          fi
        env:
          # Use a PAT if you have branch protection rules that GITHUB_TOKEN can't bypass
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
